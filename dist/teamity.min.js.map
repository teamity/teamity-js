{"version":3,"sources":["webpack://Teamity/webpack/universalModuleDefinition","webpack://Teamity/./index.js","webpack://Teamity/./node_modules/EventEmitter/src/index.js","webpack://Teamity/./symbols.js","webpack://Teamity/webpack/bootstrap","webpack://Teamity/webpack/runtime/define property getters","webpack://Teamity/webpack/runtime/hasOwnProperty shorthand","webpack://Teamity/webpack/runtime/make namespace object","webpack://Teamity/webpack/startup"],"names":["root","factory","exports","module","define","amd","this","require","kTeamityRaw","kTeamityUrl","EventEmitter","WebSkt","window","WebSocket","Teamity","url","$raw","readyState","OPEN","CLOSED","$connected","$url","onopen","bind","onerror","onclose","onmessage","_onMessage","event","body","encode","TextEncoder","Uint8Array","toString","JSON","stringify","split","pkgLen","byteLength","pkg","offset","set","send","close","Promise","resolve","reject","once","payload","emit","args","msg","data","decode","TextDecoder","arrayBuffer","then","buffer","Error","_toUint8Array","pkgIdx","findIndex","v","String","fromCharCode","topic","slice","length","superEmit","parse","e","opts","Apply","Function","prototype","apply","privateMap","WeakMap","internal","obj","has","get","maxListeners","localConsole","console","self","_events","Set","_callbacks","_console","_maxListeners","parseInt","eventName","callback","context","weight","_getCallbacks","push","sort","a","b","_has","element","listenersNumber","callbackInd","_getCallbackIndex","activeCallback","TypeError","_achieveMaxListener","warn","_callbackIsExists","arguments","add","_addCallback","onceCallback","off","call","on","splice","forEach","clear","Symbol","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","prop","hasOwnProperty","r","toStringTag","value"],"mappings":"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","file":"teamity.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Teamity\"] = factory();\n\telse\n\t\troot[\"Teamity\"] = factory();\n})(this, function() {\nreturn ","const { kTeamityRaw, kTeamityUrl } = require('./symbols')\r\nconst { default: EventEmitter } = require('EventEmitter')\r\n\r\nconst WebSkt = window.WebSocket\r\nconst pkgSplit = '\\n'\r\n\r\nclass Teamity extends EventEmitter {\r\n  constructor (url) {\r\n    super()\r\n    this[kTeamityUrl] = url\r\n  }\r\n\r\n  get $url () {\r\n    return this[kTeamityUrl]\r\n  }\r\n\r\n  get $raw () {\r\n    return this[kTeamityRaw]\r\n  }\r\n\r\n  // properties\r\n  get $connected () {\r\n    return this.$raw && this.$raw.readyState === WebSkt.OPEN\r\n  }\r\n\r\n  get $disconnected () {\r\n    return this.$raw && this.$raw.readyState === WebSkt.CLOSED\r\n  }\r\n\r\n  // methods\r\n  open () {\r\n    if (this.$connected) return\r\n\r\n    this[kTeamityRaw] = new WebSkt(this.$url)\r\n    this.$raw.onopen = super.emit.bind(this, 'connect')\r\n    this.$raw.onerror = super.emit.bind(this, 'error')\r\n    this.$raw.onclose = super.emit.bind(this, 'disconnect')\r\n    this.$raw.onmessage = _onMessage.bind(this)\r\n  }\r\n\r\n  emit (event, body) {\r\n    const encode = new TextEncoder()\r\n    if (!(event instanceof Uint8Array)) {\r\n      if (typeof event !== 'string') {\r\n        event = event.toString()\r\n      }\r\n\r\n      event = encode.encode(event)\r\n    }\r\n\r\n    if (!(body instanceof Uint8Array)) {\r\n      if (typeof body !== 'string') {\r\n        body = JSON.stringify(body)\r\n      }\r\n\r\n      body = encode.encode(body)\r\n    }\r\n\r\n    const split = encode.encode(pkgSplit)\r\n    const pkgLen = event.byteLength + split.byteLength + body.byteLength\r\n    const pkg = new Uint8Array(pkgLen)\r\n\r\n    let offset = 0\r\n    pkg.set(event, offset)\r\n    offset += event.byteLength\r\n    pkg.set(split, offset)\r\n    offset += split.byteLength\r\n    pkg.set(body, offset)\r\n\r\n    this.$raw.send(pkg)\r\n  }\r\n\r\n  close () {\r\n    this.$raw.close()\r\n  }\r\n\r\n  request (event, body) {\r\n    return new Promise((resolve, reject) => {\r\n      this.once(event, payload => {\r\n        resolve(payload)\r\n      })\r\n      this.emit(event, body)\r\n    })\r\n  }\r\n\r\n  superEmit (...args) {\r\n    super.emit(...args)\r\n  }\r\n\r\n  // events\r\n  // connect\r\n  // disconnect\r\n  // error\r\n}\r\n\r\nfunction _toUint8Array (data) {\r\n  return new Promise((resolve, reject) => {\r\n    if (data.arrayBuffer) {\r\n      data.arrayBuffer().then(buffer => {\r\n        resolve(new Uint8Array(buffer))\r\n      })\r\n    } else {\r\n      reject(new Error('data format error'))\r\n    }\r\n  })\r\n}\r\n\r\nfunction _onMessage (msg) {\r\n  try {\r\n    const { data } = msg\r\n    const decode = new TextDecoder()\r\n    _toUint8Array(data).then(payload => {\r\n      const pkgIdx = payload.findIndex(v => {\r\n        return String.fromCharCode(v) === pkgSplit\r\n      })\r\n\r\n      if (pkgIdx < 0) {\r\n        return\r\n      }\r\n\r\n      const topic = payload.slice(0, pkgIdx)\r\n      const body = payload.slice(pkgIdx + pkgSplit.length)\r\n\r\n      this.superEmit(decode.decode(topic), JSON.parse(decode.decode(body)))\r\n    })\r\n  } catch (e) {}\r\n}\r\n\r\nmodule.exports = function (opts) {\r\n  return new Teamity(opts)\r\n}\r\n","'use strict';\n\nconst Apply = Function.prototype.apply;\nconst privateMap = new WeakMap();\n\n// For making private properties.\nfunction internal(obj) {\n  if (!privateMap.has(obj)) {\n    privateMap.set(obj, {});\n  }\n\n  return privateMap.get(obj);\n}\n\n/** Class EventEmitter for event-driven architecture. */\nexport default class EventEmitter {\n  /**\n   * Constructor.\n   *\n   * @constructor\n   * @param {number|null} maxListeners.\n   * @param {object} localConsole.\n   *\n   * Set private initial parameters:\n   *   _events, _callbacks, _maxListeners, _console.\n   *\n   * @return {this}\n   */\n  constructor(maxListeners = null, localConsole = console) {\n    const self = internal(this);\n\n    self._events = new Set();\n    self._callbacks = {};\n    self._console = localConsole;\n    self._maxListeners = maxListeners === null ?\n      null : parseInt(maxListeners, 10);\n\n    return this;\n  }\n\n  /**\n   * Add callback to the event.\n   *\n   * @param {string} eventName.\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   * @param {number} weight - Using for sorting callbacks calls.\n   *\n   * @return {this}\n   */\n  _addCallback(eventName, callback, context, weight) {\n    this._getCallbacks(eventName)\n      .push({\n        callback,\n        context,\n        weight\n      });\n\n    // Sort the array of callbacks in\n    // the order of their call by \"weight\".\n    this._getCallbacks(eventName)\n      .sort((a, b) => a.weight > b.weight);\n\n    return this;\n  }\n\n  /**\n   * Get all callback for the event.\n   *\n   * @param {string} eventName\n   *\n   * @return {object|undefined}\n   */\n  _getCallbacks(eventName) {\n    return internal(this)._callbacks[eventName];\n  }\n\n  /**\n   * Get callback's index for the event.\n   *\n   * @param {string} eventName\n   * @param {callback} callback\n   *\n   * @return {number|null}\n   */\n  _getCallbackIndex(eventName, callback) {\n    return this._has(eventName) ?\n      this._getCallbacks(eventName)\n        .findIndex((element) => element.callback === callback) : null;\n  }\n\n  /**\n   * Check if we achive maximum of listeners for the event.\n   *\n   * @param {string} eventName\n   *\n   * @return {bool}\n   */\n  _achieveMaxListener(eventName) {\n    return (internal(this)._maxListeners !== null &&\n      internal(this)._maxListeners <= this.listenersNumber(eventName));\n  }\n\n  /**\n   * Check if callback is already exists for the event.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   *\n   * @return {bool}\n   */\n  _callbackIsExists(eventName, callback, context) {\n    const callbackInd = this._getCallbackIndex(eventName, callback);\n    const activeCallback = callbackInd !== -1 ?\n      this._getCallbacks(eventName)[callbackInd] : void 0;\n\n    return (callbackInd !== -1 && activeCallback &&\n      activeCallback.context === context);\n  }\n\n  /**\n   * Check is the event was already added.\n   *\n   * @param {string} eventName\n   *\n   * @return {bool}\n   */\n  _has(eventName) {\n    return internal(this)._events.has(eventName);\n  }\n\n  /**\n   * Add the listener.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   * @param {number} weight - Using for sorting callbacks calls.\n   *\n   * @return {this}\n   */\n  on(eventName, callback, context = null, weight = 1) {\n    /* eslint no-unused-vars: 0 */\n    const self = internal(this);\n\n    if (typeof callback !== 'function') {\n      throw new TypeError(`${callback} is not a function`);\n    }\n\n    // If event wasn't added before - just add it\n    // and define callbacks as an empty object.\n    if (!this._has(eventName)) {\n      self._events.add(eventName);\n      self._callbacks[eventName] = [];\n    } else {\n      // Check if we reached maximum number of listeners.\n      if (this._achieveMaxListener(eventName)) {\n        self._console.warn(`Max listeners (${self._maxListeners})` +\n          ` for event \"${eventName}\" is reached!`);\n      }\n\n      // Check if the same callback has already added.\n      if (this._callbackIsExists(...arguments)) {\n        self._console.warn(`Event \"${eventName}\"` +\n          ` already has the callback ${callback}.`);\n      }\n    }\n\n    this._addCallback(...arguments);\n\n    return this;\n  }\n\n  /**\n   * Add the listener which will be executed only once.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   * @param {number} weight - Using for sorting callbacks calls.\n   *\n   * @return {this}\n   */\n  once(eventName, callback, context = null, weight = 1) {\n    const onceCallback = (...args) => {\n      this.off(eventName, onceCallback);\n      return Apply.call(callback, context, args);\n    };\n\n    return this.on(eventName, onceCallback, context, weight);\n  }\n\n  /**\n   * Remove an event at all or just remove selected callback from the event.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   *\n   * @return {this}\n   */\n  off(eventName, callback = null) {\n    const self = internal(this);\n    let callbackInd;\n\n    if (this._has(eventName)) {\n      if (callback === null) {\n        // Remove the event.\n        self._events.delete(eventName);\n        // Remove all listeners.\n        self._callbacks[eventName] = null;\n      } else {\n        callbackInd = this._getCallbackIndex(eventName, callback);\n\n        if (callbackInd !== -1) {\n          self._callbacks[eventName].splice(callbackInd, 1);\n          // Remove all equal callbacks.\n          this.off(...arguments);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Trigger the event.\n   *\n   * @param {string} eventName\n   * @param {...args} args - All arguments which should be passed into callbacks.\n   *\n   * @return {this}\n   */\n  emit(eventName, ...args) {\n    if (this._has(eventName)) {\n      // All callbacks will be triggered sorter by \"weight\" parameter.\n      this._getCallbacks(eventName)\n        .forEach((element) =>\n          Apply.call(element.callback, element.context, args)\n        );\n    }\n\n    return this;\n  }\n\n  /**\n   * Clear all events and callback links.\n   *\n   * @return {this}\n   */\n  clear() {\n    const self = internal(this);\n\n    self._events.clear();\n    self._callbacks = {};\n\n    return this;\n  }\n\n  /**\n   * Returns number of listeners for the event.\n   *\n   * @param {string} eventName\n   *\n   * @return {number|null} - Number of listeners for event\n   *                         or null if event isn't exists.\n   */\n  listenersNumber(eventName) {\n    return this._has(eventName) ?\n      this._getCallbacks(eventName).length : null;\n  }\n}\n","module.exports = {\r\n  kTeamityRaw: Symbol('teamity.raw'),\r\n  kTeamityUrl: Symbol('teamity.url')\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(668);\n"],"sourceRoot":""}